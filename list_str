# shellcheck shell=sh
# shellcheck disable=SC2039

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao

# My idea is to using tr as less as possible.
# We preserve the original text by seprating them in 
# Focus on performiation optimization in push, pop, shift, unshift, foreach. At at the other end.

# POC: Pass at all platform
# > sep=$(printf "\001"); t="$(printf "%s\001%s\001%s" "18" "123" "456")"; echo "${t%%$sep*}"
# 18

# f(){ IFS="$(printf "\n")"; echo "|$IFS|"; echo "$*"; s="$*"; echo "${#s}"; }; f 1 2 3 
# s size is 5

# \n Using \001
# 

# Preserve
LIST_SEP="$(printf "\003")"     #

list_make(){
    local O="${1:?list_name}"
    eval "$O=0"
}

list_free(){
    eval "unset $O"
}

list_size(){
    local O="${O:?list_name}"
    eval printf "%s" "\${$O%%${LIST_SEP}*}"
    # eval printf "%s" "\$$O" | cut -d "$LIST_SEP" -f 1
    # eval "echo ${$O}"
}

# First elem is length
list_get(){
    local O="${O:?list_name}"

    local i=${1:?idx}

    local len
    len="$(list_size)"
    if [ "$i" -ge "$len" ]; then
        return 1
    fi

    eval printf "%s" "\"\$$O\"" | cut -d "$LIST_SEP" -f "$((i+2))"
}

list_push() {
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"

    local len
    len="${data%%${LIST_SEP}*}"

    local t
    local IFS="$LIST_SEP"    # For $*
    if [ "${len:-0}" -eq 0 ]; then
        t="$(printf "%s${LIST_SEP}%s" "$#" "$*")"
    else
        data="${data#*${LIST_SEP}}"
        t="$(printf "%s${LIST_SEP}%s${LIST_SEP}%s" "$((len+$#))" "$data" "$*")"
    fi
    eval $O='"$t"'
}

list_unshift() {
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"

    local len
    len="${data%%${LIST_SEP}*}"

    local t
    local IFS="$LIST_SEP"    # For $*
    if [ "${len:-0}" -eq 0 ]; then
        t="$(printf "%s${LIST_SEP}%s" "$#" "$*")"
    else
        data="${data#*${LIST_SEP}}" # body
        t="$(printf "%s${LIST_SEP}%s${LIST_SEP}%s" "$((len+$#))" "$*" "$data")"
    fi
    eval $O='"$t"'
}

list_head(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"
    local len
    len="${data%%${LIST_SEP}*}"

    [ "${len:-0}" -eq 0 ] && return 2
    data="${data#*${LIST_SEP}}"
    printf "%s" "${data%%${LIST_SEP}*}"
}

list_tail(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"
    local len
    len="${data%%${LIST_SEP}*}"

    [ "${len:-0}" -eq 0 ] && return 2
    data="${data#*${LIST_SEP}}"
    printf "%s" "${data%%${LIST_SEP}*}"
}

list_top(){ list_tail; }

list_foreach(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"
    local len
    len="${data%%${LIST_SEP}*}"
    len=${len:-0}

    local body
    body="${body#*${LIST_SEP}}"

    local f="${1:?function name}"

    local idx=0
    while [ "$idx" -lt "$len" ]; do
        "$f" "$idx" "${body%%${LIST_SEP}*}"
        body="${body#*${LIST_SEP}}"
        idx=$((idx+1))
    done

#   I don't know which is better. We shall see in the future in some stress tests.
#     local line
#     local i=0

#     ### No...
#     while read -r line; do
#         [ "$i" -ne 0 ] && eval "$f" "$i" "$(printf "$line" | tr '\001' '
# ')"
#         i=$((i+1))
#     done <<A
# $(eval printf "%s" "\$$O" | tr "\n$LIST_SEP" '\001\n' )
# A
}

list_pop(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"
    local len
    len="${data%%${LIST_SEP}*}"
    case "${len:-0}" in
    0)  return 1    ;;
    1)  printf "%s" "${data#*${LIST_SEP}}"    # body
        eval $O=0   ;;
    *)  printf "%s" "${data##*${LIST_SEP}}"
        local t
        t="$(printf "%s${LIST_SEP}%s" "$((len-1))" "${data%${LIST_SEP}*}")" ;;
    esac
    return 0
}

list_shift(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"
    local len
    len="${data%%${LIST_SEP}*}"
    case "${len:-0}" in
    0)  return 1    ;;
    1)  printf "%s" "${data#*${LIST_SEP}}"    # body
        eval $O=0   ;;
    *)  
        local body
        body="${data#*${LIST_SEP}}"
        printf "%s" "${body%%${LIST_SEP}*}"

        body="$( printf "%s${LIST_SEP}%s" "$((len-1))" "${body#*${LIST_SEP}}" )"
        eval $O="\"\$body\"" ;;
    esac
    return 0
}

list_index_of(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"

    eval printf "%s${LIST_SEP}%s" "${1:?Provide value}" "$data" | tr "\n" "\001" | awk -v RS="${LIST_SEP}" -v value="$value" \
    '
        BEGIN { exit_code = 1   }
        NR==1 { value = $0      }
        NR> 2 {
            if (value == $0) {
                print NR
                exit_code = 0
                exit 0
            }
        }
        END   { exit exit_code  }
    ' -
}

list_remove_by_value(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"

    local s
    s="$(eval printf "%s${LIST_SEP}%s" "${1:?Provide value}" "$data" | tr "\n" "\001" | awk -v RS="${LIST_SEP}" -v value="$value" \
    '
        BEGIN { }
        NR==1 { value = $0      }
        NR==2 { num = $0;   result="" }
        NR> 2 {
            if (value == $0) {
                num -= 1
            } else {
                result = result RS $0
            }
        }
        END   { 
            result = num result
            gsub("\001", "\n" result)
            printf "%s" result
        }
    ' -)"

    eval "$O=\"\$s\""
}

list_remove(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"

    local len
    len="${data%%${LIST_SEP}*}"
    len="${len:-0}"

    local idx=${1:?idx}
    local args=""

    if [ "$idx" -eq 0 ]; then
        args="3-${len}"
    elif [ "$idx" -lt $len ]; then
        args="2-$((idx+1)),$((idx+3))-$((len+2))"
    else
        return 1
    fi

    local s
    s="$( printf "%s" "$data" | cut -d "${LIST_SEP}" -f "$args" )"
    s="$(( len-1 ))${LIST_SEP}$s"

    eval "$O=\"\$s\""
    return 0
}

list_get_by_regex(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"

    eval printf "%s${LIST_SEP}%s" "${1:?Provide pattern}" "$data" | tr "\n" "\001" | awk -v RS="${LIST_SEP}" \
    '
        BEGIN { exit_code = 1   }
        NR==1 { pattern = $0      }
        NR> 2 {
            if (match($0, pattern)) {
                print NR
                print $0
                exit_code = 0
                exit 0
            }
        }
        END   { exit exit_code  }
    ' -
}


list_print(){
    local O="${O:?list_name}"
    eval printf "%s" \"\$$O\" | tr "${LIST_SEP}" "\n"
}

