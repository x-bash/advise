# shellcheck shell=bash

# expiration=1 cache_path="/tmp/a.txt" cache.cmd "cmd-path"
# cache.cmd --filepath "" --expiration=60m "cmd-path"

# expiration=1 cache.cmd curl www.github.com/v4/api
# cache.cmd "curl www.github.com/v4/api" > a.txt

str.md5(){
    local cmd
    if command -v md5 >/dev/null 2>&1; then
        cmd=md5
    else
        cmd=md5sum
    fi
    if [ -z "$1" ]; then
        $cmd | cut -d ' ' -f 1
    else
        echo -n "$1" | $cmd | cut -d ' ' -f 1
    fi
}

# cache.cmd -- cmd
# cache.cmd filepath -- cmdline
# cache.cmd 3m filepath -- cmdline
cache.cmd(){
    local HELP='
-----------------
cache.cmd [expiration, n[smhdw] ] [cache-filepath] -- <command> [...arguments]

About expiration, pattern like "n[smhdw]"
    n is number, "smhdw" is unit.
    s       second
    m       minute (60 seconds)
    h       hour (60 minutes)
    d       day (24 hours)
    w       week (7 days)

    If no unit provided, the default unit is "d"

    Example:
        cache.cmd 3m -- echo hi    # Cache the command result in future 3 minutes
        cache.cmd 3 -- echo hi     # Cache the command result in future 3 days
'

    local IFS=  ARGS=()
    while [ ! "$1" == "--" ]; do
        ARGS+=("$1"); shift
    done
    shift

    local expiration=60m filepath
    case "${#ARGS[@]}" in
        0) ;;
        1) expiration=${ARGS[0]};;
        *) expiration=${ARGS[0]}; filepath=${ARGS[1]};;
    esac

    if [[ ! "$expiration" =~ ^[0-9]+[dmwsh]?$ ]]; then
        printf "PANIC: Expiration should match pattern n[dmwsh].\n"
        printf "%s\n" "$HELP"
        return 1
    fi

    if [ -z "$filepath" ]; then
        filepath="${CACHE_FOLDER:-${TMPDIR}x-cmd-path}"
        mkdir -p "$filepath"
        filepath="$filepath/$(str.md5 "$*")"
    fi
    
    if find "$filepath" -mtime "-${expiration}" 2>/dev/null | grep -q ^; then
        [[ "$STD_DEBUG" == *cache* ]] && echo "Using cache in Cache Path: $filepath" >&2
        cat "$filepath"
    else
        [[ "$STD_DEBUG" == *cache* ]] && echo "FILEPATH does't exists or older than ${expiration} second. Update" >&2
        
        local temp_filepath; temp_filepath=$(mktemp)
        { eval "$@" && rm "$filepath" 2>/dev/null; } | tee "$temp_filepath"
        [ ! -f "$filepath" ] && mv "$temp_filepath" "$filepath"
    fi
}

cache.clear(){
    local FILEPATH="${CACHE_FOLDER:-${TMPDIR}x-cmd-path}"
    rf "$FILEPATH/*"
}

cache.cmd.setup.folder(){
    CACHE_FOLDER="${1:?Provide cache folder}"
}

# If you want a new environment for script
cache.cmd.setup(){
    X_CMD_X_BASH_CACHE_CMD_FOLDER="$(mktemp)"
    export X_CMD_X_BASH_CACHE_CMD_FOLDER
    export X_CMD_X_BASH_CACHE_CMD_FOLDER_INDEX=0
    mkdir -p "$X_CMD_X_BASH_CACHE_CMD_FOLDER"
}

# Remember teardown if you have setup
cache.cmd.teardown(){
    case "$X_CMD_X_BASH_CACHE_CMD_FOLDER" in
        /);;
        /bin*);;
        /home*);;
        # Do more work to protect the critical facility.
        *) rm -rf "$X_CMD_X_BASH_CACHE_CMD_FOLDER"
    esac

    unset X_CMD_X_BASH_CACHE_CMD_FOLDER
    unset X_CMD_X_BASH_CACHE_CMD_FOLDER_INDEX
}
