# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao


# Preserve
DICT_SEP="$(printf "\003")"     #
DICT_KV_SEP="$(printf "\004")" 

dict_make(){
    local O="${1:?list_name}"
    eval "$O=0"
}


dict_free(){
    eval "unset $O"
}

: <<'DOCTEST'
> dict_make b
> O=b dict_put 1 a
> O=b dict_put 2 b
> O=b dict_put 3 c
> O=b dict_has 2 && echo yes
yes
> O=b dict_has 4 && echo yes
DOCTEST
dict_has(){
    dict_get "$1" > /dev/null
}

: <<'DOCTEST'
> dict_make b
> O=b dict_put 1 a
> O=b dict_put 2 b
> O=b dict_put 3 c
> O=b dict_size
3
DOCTEST
dict_size(){
    local data
    data="$(eval printf "%s" "\"\$${O:?list_name}\"")"

    local len
    len="${data%%${DICT_SEP}*}"

    printf "%s" "${len:-0}"
}

: <<'DOCTEST'
> dict_make b
> O=b dict_isempty && echo yes
yes
> O=b dict_put 1 a
> O=b dict_isempty && echo yes
DOCTEST
dict_isempty(){
    [ "$(dict_size)" -eq 0 ]
}

: <<'DOCTEST'
> dict_make b
> O=b dict_put 1 a
> O=b dict_put 2 b
> O=b dict_put 3 c
> O=b dict_get 2
b
DOCTEST
dict_get(){
    local O="${O:?list_name}"
    local data
    data="$(eval printf "%s" "\"\$${O}\"")"

    eval printf "%s${DICT_SEP}%s" "${1:?Provide value}" "$data" | tr "\n" "\001" | awk -v RS="${DICT_SEP}" -v value="$value" \
    '
        BEGIN { exit_code = 1   }
        NR==1 { key = $0; keyline = ""    }
        NR> 2 {
            if (NR % 2 == 1) { # key
                if (key == $0) {
                    keyline = $0
                }
            } else {
                if (keyline != "") {
                    gsub("\001", "\n", $0)
                    printf("%s", $0)
                    exit_code = 0
                    exit 0
                }
            }
        }
        END   { exit exit_code  }
    ' -
}

dict_put(){
    local O="${O:?list_name}"
    local data
    data="$(eval printf "%s" "\"\$${O}\"")"

    local s
    s="$(printf "%s${DICT_SEP}%s${DICT_SEP}%s" "${1:?Provide key}" "${2:?Provide value}" "$data" | tr "\n" "\001" | awk -v RS="${DICT_SEP}" \
    '
        BEGIN { sw = 0; }
        NR==1 { key = $0      }
        NR==2 { value = $0    }
        NR==3 { len = $0;   result="" }
        NR> 3 {
            if (NR % 2 == 0) { # key
                if (key == $0) {
                    keyline = $0
                    sw = 1
                }
                result = result RS $0
            } else {
                if (keyline != "") {
                    result = result RS value
                } else {
                    result = result RS $0
                }
            }
        }
        END   { 
            if (sw == 1) {
                result = len result 
            } else {
                # print "fucked" > "/dev/stderr"
                result = (len+1) result RS key RS value
            }
            gsub("\001", "\n" result)
            printf("%s", result)
        }
    ' -)"

    # echo "$s"
    eval "$O=\"\$s\""
}

: <<'DOCTEST'
> dict_make b
> O=b dict_put 1 a
> O=b dict_put 2 b
> O=b dict_put 3 c
> O=b dict_remove 4 && echo yes
> O=b dict_has 2 && echo yes
yes
> O=b dict_remove 2 && echo yes
yes
> O=b dict_has 2 && echo yes
DOCTEST
dict_remove(){
    local O="${O:?list_name}"
    local data
    data="$(eval printf "%s" "\"\$${O}\"")"

    local s
    if s="$(printf "%s${DICT_SEP}%s" "${1:?Provide value}" "$data" | tr "\n" "\001" | awk -v RS="${DICT_SEP}" \
    '
        BEGIN { exit_code = 1; }
        NR==1 { key = $0;   keyline = "";      }
        NR==2 { len = $0;   result="" }
        NR> 2 {
            if (NR % 2 == 1) {  # key
                if (key == $0) {
                    len = len - 1
                    keyline = key
                    exit_code = 0
                } else {
                    result = result RS $0
                }
            } else {
                if (keyline != "") {
                    keyline = ""
                } else {
                    result = result RS $0
                }
            }
        }
        END   { 
            if (exit_code == 0) {
                gsub("\001", "\n" result)
                result = len result
                printf("%s", result)
            }
            exit exit_code
        }
    ' -)"; then

        eval "$O=\"\$s\""
    else
        return 1
    fi
}

: <<'DOCTEST'
> dict_make b
> O=b dict_put 1 a
> O=b dict_put 2 b
> O=b dict_put 3 c
> O=b dict_remove_by_regex "[1-3]+" && echo yes
yes
> O=b dict_has 1 && echo yes
> O=b dict_has 3 && echo yes
DOCTEST
dict_remove_by_regex(){
    local O="${O:?list_name}"
    local data
    data="$(eval printf "%s" "\"\$${O}\"")"

    local s
    if s="$(printf "%s${DICT_SEP}%s" "${1:?Provide value}" "$data" | tr "\n" "\001" | awk -v RS="${DICT_SEP}" \
    '
        BEGIN { exit_code = 1; }
        NR==1 { regex = $0;   keyline = "";      }
        NR==2 { len = $0;   result="" }
        NR> 2 {
            if (NR % 2 == 1) {  # key
                if ($0 ~ regex) {
                    len = len - 1
                    keyline = key
                    exit_code = 0
                } else {
                    result = result RS $0
                }
            } else {
                if (keyline != "") {
                    keyline = ""
                } else {
                    result = result RS $0
                }
            }
        }
        END   {
            if (exit_code == 0) {
                gsub("\001", "\n" result)
                result = len result
                printf("%s", result)
            }
            exit exit_code
        }
    ' -)"; then

        eval "$O=\"\$s\""
    else
        return 1
    fi
}

# TODO: add key/value filter in arguments or enviroments
# shellcheck disable=SC2120
dict_print(){
    local O="${O:?list_name}"
    local data
    data="$(eval printf "%s" "\"\$${O}\"")"

    if [ "$#" -eq 0 ]; then
        printf "${ITEM_SEP:-"\\n"}${DICT_SEP}${KV_SEP:-"="}${DICT_SEP}%s"  "$data" | tr "\n" "\001" | awk -v RS="${DICT_SEP}" -v KV_SEP="$DICT_KV_SEP" \
        '
            NR==1 {     
                if (ITEM_SEP == "\\n")  ITEM_SEP = "\n"
                if (ITEM_SEP == "\\t")  ITEM_SEP = "\t"
                if (ITEM_SEP == "\\v")  ITEM_SEP = "\v"
                ITEM_SEP=$0
            }
            NR==2 {     KV_SEP  =$0         }
            NR==3 { 
                len = $0;   result=""
            }
            NR>=4 {
                if (NR % 2 == 0) { # key
                    key = $0
                } else {
                    if (NR == 5) {
                        result = result                 key KV_SEP $0
                    } else {
                        result = result  ITEM_SEP       key KV_SEP $0
                    }
                }
            }
            END   {
                gsub("\001", "\n", result)
                printf("%s", result)
            }
        ' -
    else
        printf "${ITEM_SEP:-"\\n"}${DICT_SEP}${KV_SEP:-"="}${DICT_SEP}%s${DICT_SEP}%s" "$1" "$data" | tr "\n" "\001" | awk -v RS="${DICT_SEP}" \
        '
            NR==1 {     ITEM_SEP=$0         }
            NR==2 {     KV_SEP  =$0         }
            NR==3 {     pattern = $0; enable=""; result = "";  }
            NR>=5 {
                if (NR % 2 == 1) {          # key
                    if ($0 ~ pattern)       enable = $0
                } else {
                    if (enable != "") {
                        if (result == "")   result =            enable KV_SEP $0
                        else                result = ITEM_SEP   enable KV_SEP $0
                        enable = ""
                    }
                }
            }
            END   {
                gsub("\001", "\n", result)
                printf("%s", result)
            }
        ' -
    fi
}

dict_json(){
    local O="${O:?list_name}"
    local data
    data="$(eval printf "%s" "\"\$${O}\"")"

    printf "%s" "$data" | tr "\n\"" "\001\002" | awk -v RS="${DICT_SEP}" \
    '
        NR==1 { len = $0;   result="{";     quote = "\""}
        NR> 1 {
            if (NR % 2 == 0) { # key
                if (NR == 2) {
                    result = result "\n  " quote $0 quote ":"
                } else {
                    result = result ",\n  " quote $0 quote ":"
                }
            } else {
                result = result " " quote $0 quote
            }
        }
        END   { 
            result = result "\n}"
            gsub("\001", "\\n", result)
            gsub("\002", "\"", result)
            gsub("\v", "\\v", result)
            gsub("\b", "\\b", result)
            gsub("\t", "\\t", result)
            gsub("\r", "\\r", result)
            printf("%s", result)
        }
    ' -
}

dict_dump(){
    local O="${O:?list_name}"
    local data
    eval printf "%s" "\"\$${O}\""
}

dict_load(){
    local O="${O:?list_name}"
    local s
    s="$(cat)"
    eval "$O"='"$s"'
}


# Move to json library
json_from_kv(){
    local first=0
    local k v

    local IFS=$'\n'
    # Using consider using environment.
    local PARSE_KEY_STR="$*"

    while :; do
        read -r k || break
        read -r v || break

        if [ "$first" -eq 0 ]; then
            printf "{\n"
            first=1
        else
            printf ',\n'
        fi

        if echo "$PARSE_KEY_STR" | grep -q "$k"; then
            # TODO: using float
            if [[ "$v" =~ ^[1-9]+([0-9])*$ ]] || [ "$v" = true ] || [ "$v" = false ]; then
                printf '  "%s": %s' "$k" "$v"
                continue
            fi
        fi

        printf '  "%s": "%s"' "$k" "$v"
    done
    [ $first -ne 0 ] && printf "\n}"
}

# Move to json library
dict_toJSON(){
    # local sep=${DICT_PRINT_SEP:-" = "}
    # local IFS=$'\n'
    # list.print 1>| while read -r line; do
    #     echo "$line" | cut -d ':' -f 1 | str.unbase64
    #     echo ""
    #     echo "$line" | cut -d ':' -f 2 | str.unbase64
    #     echo ""
    # done | json_from_kv
    # local DICT_PRINT_SEP="\n"
    # dict.print | json_from_kv
    DICT_PRINT_SEP="\n" dict.print | json_from_kv "$@"

    # for i in $(list.print); do
    #     echo -n "$i" | cut -d ':' -f 1 | str.unbase64
    #     echo -n "$i" | cut -d ':' -f 2 | str.unbase64
    # done | json_from_kv
}

# Simply json stringify
# json_from_kv(){
#     printf "{\n"
#     local first=0
#     local k v
#     for i in $(list.print); do

#         if [ "$first" -eq 0 ]; then
#             first=1
#         else
#             printf ',\n'
#         fi

#         k=$(echo -n "$i" | cut -d ':' -f 1)
#         v=$(echo -n "$i" | cut -d ':' -f 2)

#         printf '  "%s": "%s"' "$(str.unbase64 "$k")" "$(str.unbase64 "$v")"
#     done
#     printf "\n}"
# }
