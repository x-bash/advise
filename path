# shellcheck shell=bash

path.ext(){
    local i ret filepath
    for i in "$@"; do
        filepath=$(basename "${i}")
        ret=${filepath##*.}
        # ret=$(cut -d '.')
        # to handle the situation: `path.extensions abc`, ret="abc", should return ""
        [ "$ret" == "$filepath" ] || printf "%s" "$ret"
    done
}

path.filename(){
    local filepath i
    for i in "$@"; do
        filepath=$(basename "$i")
        printf "%s" "${filepath%.*}"
    done
}

path.dirname(){
    local i
    for i in "$@"; do
        dirname "$i"
    done
}

path.basename(){
    local i
    for i in "$@"; do
        basename "$i"
    done
}

path.abs(){
    local p=${1:-.}
    if [ -f "$p" ]; then
        echo "$(cd "$(dirname "$p")" && pwd)/$(basename "$p")"
    else
        (cd "${1:-.}" && pwd)
    fi
}

path.script.path(){
    path.abs "${BASH_SOURCE[0]}"
}

# TODO
path.common2(){
    # local a=$1
    # local b=$2   
    :
}

path.common(){
    for i in "$@"; do
        :
    done
}

# PATH environment variable operations
# code from el-logic

path.display(){
    IFS=":"
    for i in $PATH; do 
        echo "$i";
    done
}

path.append(){
    PATH="$PATH:${1:?"Provide new path"}"
}

path.prepend(){
    PATH="${1:?"Provide new path"}:$PATH"
}

path.remove(){
    :
}

# fp

# In linux, `readlink -f <filepath>`. Not works in BSD system
# https://superuser.com/questions/330199/how-get-full-path-to-target-of-link
# TODO: using subprocess to optimize
path.readlink(){
    local TGT=${1:?"Provide name"}
    local ORI A RES
    ORI=$(pwd)
    A=$(readlink "$TGT")
    cd "$(dirname "$TGT")" && cd "$(dirname "$A")" || return 1
    RES=$(pwd)
    cd "$ORI" && echo "$RES/$(basename "$A")"
}

# Protected folders
path.rmrf(){
    @src std/str
    for i in "$@"; do
        local tgt
        tgt="$(str.trim "$i")"
        [ "$tgt" == "" ] && continue

        # TODO: add other patterns
        if [ "$tgt" == "/" ]; then
            yesno "WARNING: Sure of removing '$tgt': " || continue
        fi

        rm -rf "$i"
    done
}
