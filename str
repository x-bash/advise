# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Zhuang Linxiong        

# https://stackoverflow.com/questions/1527049/how-can-i-join-elements-of-an-array-in-bash
# join_ws also works

# Only works for single char delimeter
# a=(1 2 3)
# IFS=$'\n'; echo "${a[*]}"

str.selftest(){
    @src std/test
    test.doctest "${BASH_SOURCE[0]}"
}

: <<'DOCTEST'
> str.join "++" 1 2 3
1++2++3
DOCTEST
str.join(){
    local sep=$1
    shift 1
    local bar
    bar=$(printf "${sep}%s" "$@")
    bar=${bar:${#sep}}
    echo "$bar"
}

str.len(){
    if [ $# -ne 0 ]; then
        while [ $# -ne 0 ]; do
            echo "${#1}"
            shift
        done
    else
        local l
        l="$(cat)"
        echo "${#l}"
    fi
}

str.trim(){
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

str.trim_left(){
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    echo -n "$var"
}

str.trim_right(){
    local var="$*"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

: <<'DOCTEST'
> str.split : 1:2:3
1
2
3
> str.split : 1:2:3:4:5 -- a b c - d; echo $a $b $c $d
1 2 3 5
> result_list=($(str.split : 1:2:3)); echo "${#result_list[@]}" "${result_list[1]}"
3 2
DOCTEST
# According to str.split

# TODO: handle the case: echo -e "a\nfbfc" | str_.split f
str_.split(){
    # tr "${1:?split char}" '\n'
    case "$#" in
        1) 
            local s
            s=$(cat);
            echo -e "${s//$1/\n}"     ;;
        *) echo -e "${2//$1/\n}"            ;;
    esac
}

# str.split - -- a b c
str.work(){
    local out=() sw=0 i
    for i in "$@"; do
        (( sw ++ ))
        if [ "$i" = "--" ]; then
            out=( "${@:((sw + 1))}" )
            set -- "${@:0:sw}"
            break
        fi
    done

    echo "${#out[@]}" "${out[@]}"
    echo "$#" "$@"
}

str.split(){
    local IFS SEP=${1:?Please provide seperator}
    shift

    local sw=0 i final=-1 out=()
    for i in "$@"; do
        (( sw++ ))
        [ "$i" = -- ] && final=$sw
    done

    # Strange case str.split : --
    if [ "$final" -ne -1 ] && [ "$final" -ne $# ] ; then
        out=("${@:((final + 1))}")
        set -- "${@:0:final}"
    fi

    if [ ${#out[@]} -eq 0 ]; then
        str_.split "$SEP" "$1"
    else
        local sss=0
        for i in $(str_.split "$SEP" "$1"); do
            local var=${out[sss]}
            (( sss++ ))
            [ -z "$var" ] && return 0
            [ "$var" != "-" ] && eval "$var=$(str.repr "$i")"
        done
    fi
}

: <<'DOCTEST'
> str.upper "3abcDEF9"
3ABCDEF9
DOCTEST
str.upper(){
    if [ "$#" -eq 0 ]; then
        tr "[:lower:]" "[:upper:]"
    else
        echo -n "$1" | tr "[:lower:]" "[:upper:]"
    fi
}

: <<'DOCTEST'
> str.lower "3abcDEF9"
3abcdef9
DOCTEST
str.lower(){
    if [ "$#" -eq 0 ]; then
        tr "[:upper:]" "[:lower:]"
    else
        echo -n "$1" | tr "[:upper:]" "[:lower:]"
    fi
}

# other format using library

: <<'DOCTEST'
> str.starts_with "hi world" hi && echo yes
yes
DOCTEST
str.starts_with(){
    [[ ${1:?Provide string} == ${2:?Provide prefix}* ]]
}

: <<'DOCTEST'
> str.starts_with_regex "hi world" [a\-z]i && echo yes
yes
DOCTEST
str.starts_with_regex(){
    [[ ${1:?Provide string} =~ ^${2:?Provide prefix in regex form} ]]
}

: <<'DOCTEST'
> str.ends_with "hi world" ld && echo yes
yes
DOCTEST
str.ends_with(){
    [[ ${1?:Provide string} == *${2:?Provide suffix} ]]
}

str.ends_with_regex(){
    [[ ${1?:Provide string} =~ ${2:?Provide suffix}$ ]]
}

: <<'DOCTEST'
> str.slice "hi world" 3:
world
> str.slice "hi world" 3:-1
worl
DOCTEST
str.slice(){    
    local srcStr=${1:?Please input a string to slice}
    local start end
    
    case $# in
        1)  echo "$srcStr"; return 0;;
        2)
            if [[ "$2" == *:* ]]; then
                start=${2%:*}
                end=${2#*:}
            else
                start=$2
                (( end=$2+1 ))
            fi ;;
        *)  echo "Too many parameters" 1>&2;;
    esac

    start=${start:-0}
    end=${end:-${#srcStr}}
    [ "$end" -lt 0 ] && (( end = ${#srcStr} + end )) 

    # echo $start $end (( end - start )) >&2
    echo "${srcStr:start:(( end - start ))}"
}

: <<'DOCTEST'
> str.indexof "hi world" "world"
3
DOCTEST
str.indexof(){
    local src=${1:?Provide src string}, tgt=${2:?Provide target str}
    local after_tgt_in_src=${src#*${tgt}}
    if [ "${#after_tgt_in_src}" -eq "${#src}" ]; then
        return 1
    fi
    echo $(( ${#src} - ${#after_tgt_in_src} - ${#tgt} ))
}

## text

str.dos2unix(){
    if [ $# -eq 0 ]; then
        sed -e 's/\r//'
    else
        sed -e 's/\r//' -i "${BAK:-""}" "$@"
    fi
}

# refer https://en.wikipedia.org/wiki/Unix2dos
# refer https://www.cyberciti.biz/faq/howto-unix-linux-convert-dos-newlines-cr-lf-unix-text-format/
str.unix2dos(){
    if [ $# -eq 0 ]; then
        # test cat abc.txt | sed -e 's/$/\r/' | cat -vet -
        sed -e $'s/$/\r/'
    else
        # test cat abc.txt | sed -e 's/$/\r/' | cat -vet -
        # cat abc.txt | sed -e 's/$/\r/' | cat -vet -
        sed -e 's/$/\r/' -e "$ s/..$//g" -i "${BAK:-""}" "$@"
        # sed -e 's/\r*$/\r/' -i ${BAK:-""} "$@"
        # sed -e "s/$/^M/" -i ${BAK:-""} "$@"
    fi
}

# Reference: https://stackoverflow.com/questions/5349718/how-can-i-repeat-a-character-in-bash
str.repeat(){
    local t character="${1:?Charactor}" number="${2:?Number of characters}"
    case "${#character}" in
    0) echo "Wrong" >&2;;
    1) seq -f $character -s '' $number ;;
    *) t="$(seq -f 1 -s '' $number)"; echo "${t//1/$character}" ;;
    esac
}

# USAGE 1, remove in file: remove_eol_space filepath
# USAGE 2, remove in file and backup with BAK as extensions: BAK='.bak' remove_eol_space filepath
# USAGE 3, remove and output to stdout: cat filepath | remove_eol_space
str.remove_eol_space(){
    if [ $# -eq 0 ]; then
        sed -e 's/[[:blank:]]*$//g'
    else
        sed -e 's/[[:blank:]]*$//g' -i "${BAK:-""}" "$@"
    fi
}

# rot13(){
#     tr '[a-zA-Z]' '[n-za-mN-ZA-M]'
# }

str._rot(){
    local rot=${1:-13}
    local letter='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789=-+'
    local before=${letter:0:$rot}
    local after=${letter:$rot}
    tr $letter $after$before
}

str.rot.encode(){
    local ROT=${1:?Provide rot number}
    shift
    if [ $# -eq 0 ]; then
        str._rot "$ROT"
    else
        echo -n "$1" | str._rot "$ROT"
    fi
}

str.rot.decode(){
    local ROT=${1:?Provide rot number}
    shift
    if [ $# -eq 0 ]; then
        str._rot $(( 65 - ROT ))
    else
        echo -n "$1" | str._rot $(( 65 - ROT ))
    fi
}

str.brb.encode(){
    local ROT=${1:?Provide rot number}
    shift
    if [ $# -eq 0 ]; then
        base64 | str.rot.encode "$ROT" | base64;
    else
        echo -n "$1" | base64 | str.rot.encode "$ROT" | base64;
    fi
}

str.brb.decode(){
    local ROT=${1:?Provide rot number}
    shift
    if [ $# -eq 0 ]; then
        base64 --decode | str.rot.decode "$ROT" | base64 --decode
    else
        echo -n "$1" | base64 --decode | str.rot.decode "$ROT" | base64 --decode
    fi
}

str.base64(){
    if [ $# -eq 0 ]; then
        base64
    else
        str.trim "$(echo -n "${1:?Provide string}" | base64)"
    fi
}

str.unbase64(){
    if [ $# -eq 0 ]; then
        base64 --decode
    else
        str.trim "$(echo -n "${1:?Provide string}" | base64 --decode)"
    fi
}

str.md5(){
    local cmd
    if command -v md5 >/dev/null 2>&1; then
        cmd=md5
    elif command -v md5sum >/dev/null 2>&1; then
        cmd=md5sum
    fi
    if [ -z "$1" ]; then
        $cmd | cut -d ' ' -f 1
    else
        echo -n "$1" | $cmd | cut -d ' ' -f 1
    fi
}

: <<'DOCTEST'
> str.sha "hi x-bash"
b595755ac2c4a251bef3187cda6550e25e72752a
DOCTEST
str.sha(){
    local ALGOR=${ALGOR:-1}
    if command -v shasum >/dev/null 2>&1; then
        echo -n "${1:?str to encrypt}" | shasum -a "$ALGOR" | cut -d ' ' -f 1
        return 0
    fi
    
    local cmd=sha${ALGOR}sum
    if command -v "$cmd" >/dev/null 2>&1; then
        echo -n "${1:?str to encrypt}" | $cmd | cut -d ' ' -f 1
        return 0
    fi
    
    # TODO: Install x and provide encryption
}

str.sha1(){     ALGOR=1 str.sha "$@"; }
str.sha256(){   ALGOR=256 str.sha "$@"; }
str.sha512(){   ALGOR=512 str.sha "$@"; }

str.repr(){
    # echo "\"$(echo "$1" | sed s/\"/\\\\\"/g)\""
    # echo "\"${1//\"/\\\\\"}\""
    # echo "\"${1//\"/\\\"}\""
    printf '"%s"' "${1//\"/\\\"}"
}

# str.parse_arg_list(){

# }


## Regular Expression design

export OR="\|"

R.wrap(){
    echo -n "\($1\)"
}

R.or(){
    R.wrap "$(str.join "\|" "$@")"
}

# IP_0_255="[0-9]${OR}\([1-9][0-9]\)${OR}\(1[0-9][0-9]\)${OR}\(2[0-4][0-9]\)${OR}\(25[0-5]\)"

# shellcheck disable=SC2046,SC2006
IP_0_255=$( R.or `R.wrap "[0-9]"` `R.wrap "[1-9][0-9]"` `R.wrap "1[0-9][0-9]"` `R.wrap "2[0-4][0-9]"` `R.wrap "25[0-5]"` )
export IP="\\b${IP_0_255}\.${IP_0_255}\.${IP_0_255}\.${IP_0_255}\\b"

# [[:alpha:]] [[:alphanum:]] [[:number:]]

