#shellcheck shell=bash

str.repr(){
    # echo "\"$(echo "$1" | sed s/\"/\\\\\"/g)\""
    # echo "\"${1//\"/\\\\\"}\""
    echo "\"${1//\"/\\\"}\""
}

list.repr(){
    # echo "\"$(echo "$1" | sed s/\"/\\\\\"/g)\""
    # echo "\"${1//\"/\\\\\"}\""

    printf "( "
    for i in "$@"; do
        printf "\"${i//\"/\\\"}\""
        printf " "
    done
    printf ")"
}

str.trim(){
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

# shellcheck disable=SC2142
alias param='if ! eval "$(param.__parse "$@")"; then return $? 2>/dev/null || exit $?; fi <<<'

param._type.regex(){
    local c val="${1:?Provide value}"
    shift
    for c in "$@"; do
        if [[ "$val" =~ ^($c)$ ]]; then
            return 0
        fi
    done
    return 1
}

param._type.streq(){
    local c val="${1:?Provide value}"
    shift
    for c in "$@"; do
        if [ "$val" = "$c" ]; then
            return 0
        fi
    done
    return 1
}

# TODO: avoid IFS influence on this function
param.__parse(){

    local i IFS=

    local varlist=()
    local typelist=()
    local vallist=()
    local deslist=()
    local deflist=()
    local oplist=()
    local choicelist=()

    local line

    # Step 1: Parsing into tokens
    while read -r line; do
        line="$(str.trim "$line")"
        [ "$line" = "" ] && continue

        local all_arg_arr=() IFS=
        # all_arg_arr=( "$(str.arg "$line")" )
        IFS=$'\n' # different from '\n'
        # shellcheck disable=SC2207 # this rule is wrong
        all_arg_arr=( $(echo "$line" | xargs -n 1) )

        varname=${all_arg_arr[0]}

        if [[ $varname == *=* ]]; then
            local default="${varname#*=}"
            varname="${varname%%=*}"
            varlist+=("$varname")
            vallist+=("$default")
            deflist+=("$default")
        else
            varlist+=("$varname")
            vallist+=("")
            deflist+=("")
        fi

        IFS=$'\n'

        case "${all_arg_arr[1]}" in
        = | =~ | =str | =str? | =float | =int | =\[?\] | =? | =~\[?\] | =~? )
            oplist+=( "${all_arg_arr[1]}" )
            choicelist+=( "${all_arg_arr[*]:2}" )
            ;;
        *)
            description="${all_arg_arr[1]}"
            oplist+=( "${all_arg_arr[2]}" )
            choicelist+=( "${all_arg_arr[*]:3}" )
            ;;
        esac 

        deslist+=("$description")
        typelist+=("argenv")
    done <<< "$(cat -)"

    echo "local _varlist 2>/dev/null"
    echo "_varlist=$(list.repr "${varlist[@]}")"

    # echo "--------"
    # echo "var list: ${varlist[@]}"
    # echo "val list: ${vallist[@]}"
    # echo "deslist: ${#deslist[@]}"
    # echo "dflist: ${deflist[@]}"
    # echo "op list: ${oplist[@]}"
    # echo "--------"

    # echo setup environment value >&2
    
    # Step 2: Init the valus with the enviroment
    for (( i=0; i < ${#varlist[@]}; ++i )); do
        [[ ! "${typelist[i]}" = *env ]] && continue
        local name=${varlist[i]}
        vallist[i]=${!name}
    done
    
    local rest_argv_str="local _rest_argv=( "

    # echo setup parameter value >&2

    # Step 3: Init the values with the parameter
    while [ ! "$#" -eq 0 ]; do
        local parameter_name=$1
        if [[ "$parameter_name" == --* ]]; then
            shift
            parameter_name=${parameter_name:2}
            local sw=0 i
            for i in "${!varlist[@]}"; do
                [[ ! "${typelist[i]}" = arg* ]] && continue
                local _varname=${varlist[i]}
                if [ "$parameter_name" == "$_varname" ]; then
                    vallist[i]=$1
                    shift
                    sw=1
                    break
                fi
            done
            if [ $sw -eq 0 ]; then
                echo "ERROR: Unsupported parameter: --$parameter_name" >&2
                echo "return 1 2>/dev/null"
                return 0
            fi
        else
            rest_argv_str+="$(str.repr "$parameter_name") "
            shift
        fi
    done

    echo "$rest_argv_str ) 2>/dev/null"

    # Step 4: If value is NULL, use the default value.
    for i in "${!varlist[@]}"; do
        local name="${varlist[i]}"
        local val="${vallist[i]}"
        if [ "$val" == "" ]; then
            vallist[i]=${deflist[i]}
        fi
    done

    local CHOICE_LIST_MUST_NOT_BE_EMTPY='
        [ "${#choice[@]}" -eq 0 ] && {
            echo "echo ERROR: Please provide candidate list right after $op for parameter $name >&2"
            echo "return 1 2>/dev/null"
            return 0
        }
    '

    # Step 4: Type check and output the code
    for i in "${!varlist[@]}"; do
        local name="${varlist[i]}"
        local val="${vallist[i]}"

        local op="${oplist[$i]}"
        # TODO: Should we quote? Please find out. 
        # No. It should be populated.
        local choice=( ${choicelist[i]} )

        case "$op" in
        =~)
            echo "$op" >&2
            eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"
            if ! param._type.regex "$val" "${choice[@]}"; then
                echo "echo ERROR:  $name='$val' NOT match any regex defined >&2"
                echo 'return 1 2>/dev/null'
                return 0
            fi;;
        =)
            eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"
            if ! param._type.streq "$val" "${choice[@]}"; then
                echo "echo ERROR: $name='$val' Not one of the candidate set >&2"
                echo 'return 2 2>/dev/null'
                return 0
            fi ;;
        =str | =int)
            if [ ${#val} -eq 0 ]; then
                echo "echo ERROR: A non-null value is expected. >&2"
                echo 'return 1 2>/dev/null'
                return 1
            fi

            if [ "$op" = "=int" ]; then
                if  [[ ! "$val" =~ ^[\ \t]+[0-9]+[\ \t]+$ ]]; then
                    echo "echo ERROR: $name='$val' An integer expected. >&2"
                    echo 'return 1 2>/dev/null'
                    return 1
                fi
            fi

            [ "${#choice[@]}" -ne 0 ] && {
                if ! param._type.streq "$val" "${choice[@]}"; then
                    echo "echo ERROR: $name='$val' Not inside the $op set >&2"
                    echo 'return 1 2>/dev/null'
                    return 0
                fi 
            };;
        =\[?\] | =?)
            eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"

            local sep=${op:1:1}
            [[ "$op" == =\[?\] ]] &&  sep=${op:2:1}
            local data=( $(echo "$val" | tr "$sep" '\n') )
            [ ${#data[@]} -eq 0 ] && data=("")
            local datum
            for datum in "${data[@]}"; do
                if ! param._type.streq "$datum" "${choice[@]}"; then
                    echo "echo ERROR: $name='$val' Split with $sep. And element $datum DOESNOT match the string set >&2"
                    echo 'return 2 2>/dev/null'
                    return 0
                fi
            done

            if [[ "$op" == =\[?\] ]]; then
                echo "local $name 2>/dev/null"
                echo "$name=$(list.repr "${data[@]}")"
                continue
            fi ;;

        =~\[?\] | =~? )
            eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"

            local sep=${op:2:1} i match
            [[ "$op" == =~\[?\] ]] && sep=${op:3:1}
            local data=( $(echo "$val" | tr "$sep" '\n') )
            [ ${#data[@]} -eq 0 ] && data=("")
            local datum
            for datum in "${data[@]}"; do
                if ! param._type.regex "$datum" "${choice[@]}"; then
                    echo "echo ERROR: $name='$val' Split with $sep. And element $datum DOESNOT match the regex set >&2"
                    echo 'return 2 2>/dev/null'
                    return 0
                fi
            done

            if [[ "$op" == =~\[?\] ]]; then
                echo "local $name 2>/dev/null"
                echo "$name=$(list.repr "${data[@]}")"
                continue
            fi ;;
        *)
            [ "$op" == "" ] || echo ": TODO: $op" >&2 ;;
        esac

        # TODO: notice the '' inside the string
        # echo "$val: $val" >&2
        echo "local $name 2>/dev/null"
        echo "$name=$(str.repr "$val")"
        # echo "local $name=$(str.repr "$val")"
        # echo "--------"
    done
}

shopt -s expand_aliases
