#shellcheck shell=bash

str.repr(){
    printf '"%s"' "${1//\"/\\\"}"
}

list.repr(){
    printf "( "
    for i in "$@"; do
        printf '"%s" ' "${i//\"/\\\"}"
    done
    printf ")"
}

str.trim(){
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

line.to_array.trim.ignore_empty(){
    local name=${1:?Array name}
    local line arr=()
    while read -r line; do
        line="$(str.trim "$line")"
        [ "$line" = "" ] && continue
        arr+=("$line")
    done <<< "$(cat -)"
    eval "$name"'=("${arr[@]}")'
}

# shellcheck disable=SC2142
alias param='if ! eval "$(param.__parse "$@")"; then return $? 2>/dev/null || exit $?; fi <<<'

param._type.regex(){
    local c val="$1" # val="${1:?Provide value}"
    shift
    for c in "$@"; do
        if [[ "$val" =~ ^($c)$ ]]; then
            return 0
        fi
    done
    return 1
}

param._type.streq(){
    local c val="$1" # val="${1:?Provide value}"
    shift
    for c in "$@"; do
        if [ "$val" = "$c" ]; then
            return 0
        fi
    done
    return 1
}

param._type.check(){
    # shellcheck disable=SC2016
    local CHOICE_LIST_MUST_NOT_BE_EMTPY='
        [ "${#@}" -eq 0 ] && {
            echo "echo ERROR: Please provide candidate list right after $op for parameter[$name] >&2"
            echo "return 1 2>/dev/null"
            return 0
        }
    '

    local IFS=$'\n'

    local name="$1" val="$2" op="$3"; shift 3
    case "$op" in
    =~)
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"
        if ! param._type.regex "$val" "$@"; then
            echo "echo ERROR:  $name='$val' NOT match any regex defined >&2"
            echo 'return 1 2>/dev/null'
            return 1
        fi;;
    =)
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"
        if ! param._type.streq "$val" "$@"; then
            echo "$val" "$@" >&2
            echo "echo ERROR: $name='$val' Not one of the candidate set. >&2"
            echo 'return 2 2>/dev/null'
            return 1
        fi ;;
    =str | =int)
        if [ ${#val} -eq 0 ]; then
            echo "echo ERROR: A non-null value is expected for parameter: $name >&2"
            echo 'return 1 2>/dev/null'
            return 1
        fi

        if [ "$op" = "=int" ]; then
            if  [[ ! "$val" =~ ^[\ \t]+[0-9]+[\ \t]+$ ]]; then
                echo "echo ERROR: $name='$val' An integer expected. >&2"
                echo 'return 1 2>/dev/null'
                return 1
            fi
        fi

        [ "${#@}" -ne 0 ] && {
            if ! param._type.streq "$val" "$@"; then
                echo "echo ERROR: $name='$val' Not inside the $op set. >&2"
                echo 'return 1 2>/dev/null'
                return 1
            fi 
        };;
    =\[?\] | =?)
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"

        local sep=${op:1:1};
        [[ "$op" == '=['?']' ]] &&  sep=${op:2:1}
        # shellcheck disable=SC2207
        local data=( $(echo "$val" | tr "$sep" '\n') ) # should not quote '$(...)'
        [ ${#data[@]} -eq 0 ] && data=("")
        local datum
        
        for datum in "${data[@]}"; do
            if ! param._type.streq "$datum" "$@"; then
                echo "echo ERROR: [$name='$val'] After splited with \'$sep\', element '$datum' does NOT match the string set >&2"
                echo 'return 2 2>/dev/null'
                return 1
            fi
        done

        if [[ "$op" == '=['?']' ]]; then
            [[ ! "$name" == \$* ]] && {
                echo "local $name 2>/dev/null"
                echo "$name=$(list.repr "${data[@]}")"
            }
            return 0 # continue
        fi ;;
    =~\[?\] | =~? )
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"

        local sep=${op:2:1};    
        [[ "$op" == '=~['?']' ]] && sep=${op:3:1}
        # shellcheck disable=SC2207
        local data=( $(echo "$val" | tr "$sep" '\n') ) # should not quote '$(...)'
        [ ${#data[@]} -eq 0 ] && data=("")
        local datum
        for datum in "${data[@]}"; do
            param._type.regex "$datum" "$@" && continue
            echo "echo ERROR: [$name='$val']. After splited with \'$sep\', element '$datum' does NOT match the regex set >&2"
            echo 'return 2 2>/dev/null'
            return 1
        done

        if [[ "$op" == '=~['?']' ]]; then
            [[ ! "$name" == \$* ]] && {
                echo "local $name 2>/dev/null"
                echo "$name=$(list.repr "${data[@]}")"
            }
            return 0 # continue
        fi ;;
    *)  [ "$op" == "" ] || echo ": TODO: $op" >&2 ;;
    esac

    [[ ! "$name" == \$* ]] && {
        echo "local $name 2>/dev/null"
        echo "$name=$(str.repr "$val")"
    }
    return 0
}

param.__parse(){
    local i IFS=$'\n'

    local varlist=() typelist=()  deslist=()
    local vallist=() deflist=() # default
    local oplist=() choicelist=()

    local arg_description arg_deslist=() arg_oplist=() arg_choicelist=()
    local rest_argv_des="" rest_argv_op="" rest_argv_choices=()

    local linelist=() line nextline lineindex all_arg_arr all_arg_arr2
    line.to_array.trim.ignore_empty linelist 

    # Step 1: Parsing into tokens
    # for line in "${linelist[@]}"; do
    for (( lineindex=0; lineindex < ${#linelist[@]}; lineindex++ )); do
        line="${linelist[lineindex]}"

        # shellcheck disable=SC2207 # this rule is wrong
        all_arg_arr=( $(echo "$line" | xargs -n 1) ) # all_arg_arr=( "$(str.arg "$line")" )

        nextline="${linelist[lineindex+1]}"
        if [[ "$nextline" = =* ]]; then
            # shellcheck disable=SC2207 # this rule is wrong
            all_arg_arr2=( $(echo "$nextline" | xargs -n 1) )
            all_arg_arr+=("${all_arg_arr2[@]}")
            (( lineindex ++ ))
        fi

        varname="${all_arg_arr[0]}"

        ###### BEGIN: handle #1 like
        if [[ "$varname" =~ \#[:number:]+ ]]; then
            varname="${varname:1}"
            case "${all_arg_arr[1]}" in
            = | =~ | =str | =str? | =float | =int | =\[?\] | =? | =~\[?\] | =~? )
                arg_oplist+=( "${all_arg_arr[1]}" )
                arg_choicelist+=( "${all_arg_arr[*]:2}" ) ;;
            *)
                arg_description="${all_arg_arr[1]}"
                arg_oplist+=( "${all_arg_arr[2]}" )
                arg_choicelist+=( "${all_arg_arr[@]:3}" ) ;;
            esac
            arg_deslist+=("$arg_description")
            continue
        fi
        ###### END: handle #1 like

        ###### BEGIN: handle ... for rest_argv
        if [ "$varname" = "..." ]; then
            case "${all_arg_arr[1]}" in
            = | =~ | =str | =str? | =float | =int | =\[?\] | =? | =~\[?\] | =~? )
                rest_argv_op="${all_arg_arr[1]}"
                rest_argv_choices=( "${all_arg_arr[@]:2}" ) ;;
            *)
                rest_argv_des="${all_arg_arr[1]}"
                rest_argv_op="${all_arg_arr[2]}"
                rest_argv_choices=( "${all_arg_arr[@]:3}" ) ;;
            esac
            continue
        fi
        ###### END: handle ... for rest_argv
        
        if [[ "$varname" =~ ^(arg)+((ENV)|(env))+: ]]; then
            typelist+=( "${varname%%:*}" )
            varname="${varname#*:}"
        else
            typelist+=("arg")
        fi

        if [[ "$varname" == *=* ]]; then
            local default="${varname#*=}"
            varname="${varname%%=*}"
            varlist+=("$varname")
            vallist+=("$default") # Default value
            deflist+=("$default")
        else
            varlist+=("$varname")
            vallist+=("")
            deflist+=("")
        fi

        case "${all_arg_arr[1]}" in
        = | =~ | =str | =str? | =float | =int | =\[?\] | =? | =~\[?\] | =~? )
            oplist+=( "${all_arg_arr[1]}" )
            choicelist+=( "${all_arg_arr[*]:2}" ) ;;
        *)
            description="${all_arg_arr[1]}"
            oplist+=( "${all_arg_arr[2]}" )
            choicelist+=( "${all_arg_arr[*]:3}" ) ;;
        esac 

        deslist+=("$description")
    done

    echo "local _varlist 2>/dev/null"
    echo "_varlist=$(list.repr "${varlist[@]}")"

    # echo "--------"
    # echo "var list: ${varlist[@]}"
    # echo "val list: ${vallist[@]}"
    # echo "deslist: ${#deslist[@]}"
    # echo "dflist: ${deflist[@]}"
    # echo "op list: ${oplist[@]}"
    # echo "--------"
    
    # Step 2: Init the valus with the enviroment
    for (( i=0; i < ${#varlist[@]}; ++i )); do
        local name=${varlist[i]}
        if [[ "${typelist[i]}" = *env ]]; then
            :
        elif [[ "${typelist[i]}" = *ENV ]]; then
            name="$(echo "$name" | tr '[:lower:]' '[:upper:]')"
        else
            continue
        fi

        local value="${!name}"
        [ -n "$value" ] && vallist[i]=$value
    done

    local rest_argv_str="local _rest_argv=( "
    local rest_argv=()

    # Step 3: Init the values with the parameter
    while [ ! "$#" -eq 0 ]; do
        local parameter_name=$1
        if [[ ! "$parameter_name" == --* ]]; then
            rest_argv_str+="$(str.repr "$parameter_name") "
            rest_argv+=("$parameter_name")
            shift
            continue
        fi

        parameter_name=${parameter_name:2}
        shift
        local sw=0 i
        for i in "${!varlist[@]}"; do
            [[ ! "${typelist[i]}" = arg* ]] && continue
            local _varname=${varlist[i]}
            if [ "$parameter_name" == "$_varname" ]; then
                vallist[i]=$1
                shift
                sw=1
                break
            fi
        done
        if [ $sw -eq 0 ]; then
            echo "ERROR: Unsupported parameter: --$parameter_name" >&2
            echo "return 1 2>/dev/null"
            return 0
        fi
            
    done

    echo "$rest_argv_str ) 2>/dev/null"

    # Step 4: If value is NULL, use the default value. Then, Type-CHECK
    for i in "${!varlist[@]}"; do
        # For some starnge case, it might not be redundant.
        # if [ "${vallist[i]}" == "" ]; then
        #     vallist[i]=${deflist[i]}
        # fi
        # shellcheck disable=SC2206
        local choices=( ${choicelist[i]} )  # should not quote '$(...)'

        param._type.check "${varlist[i]}" "${vallist[i]}" "${oplist[$i]}" "${choices[@]}"
        [ $? -eq 1 ] && return 1
    done

    # Step 5: Handle the parameter number
    local max_i=0
    for i in "${!arg_deslist[@]}"; do

        [ $max_i -lt "$i" ] && max_i=$i

        # shellcheck disable=SC2206
        local choices=( ${arg_choicelist[i]} )  # should not quote '$(...)'

        param._type.check "\$$i" "${rest_argv[i]}" "${oplist[$i]}" "${choices[@]}"
        [ $? -eq 1 ] && return 1
    done

    (( max_i ++ ))

    # Step 6: Handle the rest parameter
    if [ -n "$rest_argv_op" ]; then
        for i in "${!rest_argv[@]:max_i}"; do
            param._type.check "\$$i" "${rest_argv[i]}" "$rest_argv_op" "${rest_argv_choices[@]}"
            [ $? -eq 1 ] && return 1
        done
    fi
}

shopt -s expand_aliases
