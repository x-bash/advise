# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao

# assert(){
#     if [ $# -ne 0 ]; then
#         eval "$*"
#     else
#         code=$(cat)
#         eval "$code"
#     fi

#     # shellcheck disable=SC2181
#     if [ "$?" -eq 0 ]; then
#         return 0
#     else
#         echo "$MSG"
#         return 1
#     fi
# }

# assert "$org" =~ [\d]{2} [\d]{4}
# assert "$repo" = gitee


@assert(){
    local value=${!1}
    shift
    assert "$value" "$@"
}

# design principle:
# when to use name evaluation?
# 

assert(){
    local value="$1"
    local op="$2"
    shift 2
    case "$op" in
    =) assert.within "$value" "$@";;
    =~) assert.within_regex "$value" "$@";;
    *) return 1;;
    esac
}

assert.within(){
    local value="$1"
    shift
    for i in "$@"; do
        if [ "$value" = "$i" ]; then
            return 0
        fi
    done
    return 1
}

assert.within_regex(){
    local value="$1"
    shift
    for i in "$@"; do
        if [[ "$value" =~ $i ]]; then
            return 0
        fi
    done
    return 1
}

assert.eq(){
    local real=${1:?Real value}
    while [ $# -gt 1 ]; do
        shift
        if [ "$real" != "$1" ]; then
            echo "Failed. Expect '$real' equals to '$1'" >&2
            return 1
        fi
    done
}

assert.t(){
    if eval "$*"; then
        :
    else
        echo "${MSG:-"Expect command execution to be true: $*"}" >&2
    fi
}

assert.f(){
    if eval "$*"; then
        echo "${MSG:-"Expect command execution to be false: $*"}" >&2
    else
        :
    fi
}

# Two ways
# assert.grep hi <<<"hello hi"
# assert.grep hi <README.md
assert.grep(){
    if grep "${1:?Please provide grep pattern}"; then
        return 0
    else
        echo "${MSG:-Grep Pattern Failed matching: $1}"
        return 1
    fi
}

assert.float(){
    while [ $# -gt 0 ]; do
        [[ "$1" =~ ^[\ \t]+[0-9]+(.[0-9]+)?[\ \t]+$ ]]
        shift
    done
}

assert.int(){
    while [ $# -gt 0 ]; do
        [[ "$1" =~ ^[\ \t]+[0-9]+[\ \t]+$ ]]
        shift
    done
}

assert.array(){
    while [ $# -gt 0 ]; do
        declare -p "${1:?Please provide variable name}" 2> /dev/null | grep -q '^declare \-a'
        shift
    done
}

testFun(){
    # Do it in usual way
    local TMP_1 TMP_2
    TMP_1=$(file.tmp)
    TMP_2=$(file.tmp)
    
    docker run -it ubuntu bash > "$TMP_1"
    MSG="testFun failed" \
        assert.grep "work" -- "work" <"$TMP_1"
    assert.grep "$(line "$TMP_1" 2)" "$TMP_2"
    MSG="testFun failed for reason like" \
        assert.grep "$(line "$TMP_1" 3)" "$TMP_2"

    # assert.grep "work" -- "testFun failed" <$TMP_1
    # assert.grep $(line $TMP_1 2) $TMP_2
    # assert.grep "$(line $TMP_1 3)" $TMP_2 -- "testFun failed for reason like" 

    # assert.eq 2 $(line $TMP_1 3)
    # assert.eq 2 $(file.line $TMP_1 3)
    # assert.eq 2 $(sed -n 3p $TMP_1)
}

# Example:
# TIMEOUT=3 MSGURE="Fail if wrong" @ts "work1" testFun1
# TIMEOUT=3 MSGURE="Fail if wrong" @testsuite "work1" testFun1
# TIMEOUT=5 @ts "work2" testFun2

assert.not_empty(){
    for i in "$@"; do
        [ -n "${!i}" ] || return 1
    done
}

assert.str_length(){
    local varname=${1:?Please provide variable name}
    local val=${!$varname}
    local len=${#val}
    local expected_len=${2:?Expected length}
    if [ "$len" -eq "$expected_len" ]; then
        return 0
    else
        return 1
    fi
}

assert.str_eq(){
    local val=${!1:?Please provide variable name}
    shift
    for i in "$@"; do
        if [ "$val" = "$i" ]; then
            return 0
        else
            return 1
        fi
    done
}

assert.str_match_regex(){
    local val=${!1:?Please provide variable name}
    shift
    for i in "$@"; do
        if [[ "$val" =~ ^$i$ ]]; then
            return 0
        else
            return 1
        fi
    done
}
