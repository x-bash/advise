# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao

assert.selftest(){
    @src std/test
    test.doctest "${BASH_SOURCE[0]}"
}

# assert(){
#     if [ $# -ne 0 ]; then
#         eval "$*"
#     else
#         code=$(cat)
#         eval "$code"
#     fi

#     # shellcheck disable=SC2181
#     if [ "$?" -eq 0 ]; then
#         return 0
#     else
#         echo "$MSG"
#         return 1
#     fi
# }

# assert "$org" =~ [\d]{2} [\d]{4}
# assert "$repo" = gitee


@assert(){
    local value=${!1}
    shift
    assert "$value" "$@"
}

# design principle:
# when to use name evaluation?
# 

assert(){
    local value="$1"
    local op="$2"
    shift 2
    case "$op" in
    =) assert.within "$value" "$@";;
    =~) assert.within_regex "$value" "$@";;
    *) return 1;;
    esac
}

: <<DOCTEST
> assert.within 1abc 1abc1 1abc2 && echo yes
> assert.within 1abc 1abc1 1abc2 1abc abc3 && echo yes
yes
DOCTEST
assert.within(){
    local c value="$1"
    shift
    for c in "$@"; do
        if [ "$value" = "$c" ]; then
            return 0
        fi
    done
    return 1
}


: <<DOCTEST
> assert.within_regex 1abc 1abc1 1abc2 && echo yes
> assert.within_regex 1abc 1abc1 1abc2 1abc abc3 && echo yes
yes
> assert.within_regex 1abc 1abc1 1abc2 [0-9][a-z]+ abc3 && echo yes
yes
DOCTEST
assert.within_regex(){
    local c value="$1"
    shift
    for c in "$@"; do
        # echo "--- $value" "^($c)$" >&2
        if [[ "$value" =~ ^($c)$ ]]; then
            return 0
        fi
    done
    return 1
}

: <<DOCTEST
> assert.eq 1abc 1abc1 1abc2 2>/dev/null && echo yes
> assert.eq 1abc 1abc 1abc && echo yes
yes
DOCTEST
assert.eq(){
    local real=${1:?Real value}
    while [ $# -gt 1 ]; do
        shift
        if [ "$real" != "$1" ]; then
            echo "Failed. Expect '$real' equals to '$1'" >&2
            return 1
        fi
    done
    return 0
}


: <<DOCTEST
> assert.t "sleep 1s" 2>/dev/null && echo yes
yes
> assert.t "[ 5 -eq 3 ]" 2>/dev/null && echo yes
> assert.t "[ 3 -eq 3 ]" 2>/dev/null && echo yes
yes
DOCTEST
assert.t(){
    if eval "$*"; then
        return 0
    else
        echo "${MSG:-"Expect command execution to be true: $*"}" >&2
        return 1
    fi
}

: <<DOCTEST
> assert.f "sleep 1s" 2>/dev/null && echo yes
> assert.f "[ 5 -eq 3 ]" 2>/dev/null && echo yes
yes
> assert.f "[ 3 -eq 3 ]" 2>/dev/null && echo yes
DOCTEST
assert.f(){
    if eval "$*"; then
        echo "${MSG:-"Expect command execution to be false: $*"}" >&2
        return 1
    else
        return 0
    fi
}

# There is two ways to use assert.grep
: <<DOCTEST
> assert.grep hi <<<"hello hi" 1>/dev/null && echo yes
yes
> assert.grep "test.doctest" 2>/dev/null <"${BASH_SOURCE[0]}" && echo yes
yes
DOCTEST
assert.grep(){
    if grep "${1:?Please provide grep pattern}" 1>/dev/null; then
        return 0
    else
        echo "${MSG:-Grep Pattern Failed matching: $1}" >&2
        return 1
    fi
}

: <<DOCTEST
> assert.float 1.2 1.0 1.1 34.1 && echo yes
yes
> assert.float 1.2 1.0 1.- 34 2>/dev/null && echo yes
DOCTEST
assert.float(){
    while [ $# -gt 0 ]; do
        [[ "$1" =~ ^[\ \t]?[0-9]+(.[0-9]+)?[\ \t]?$ ]] || {
            echo "${MSG:-"Expect var to be of float type: $*"}" >&2
            return 1
        }
        shift
    done
    return 0
}

: <<DOCTEST
> assert.int 1 2 3 " 5 " && echo yes
yes
> assert.int 1 2 1.2 3 2>/dev/null && echo yes
DOCTEST
assert.int(){
    while [ $# -gt 0 ]; do
        [[ "$1" =~ ^[\ \t]?[0-9]+[\ \t]?$ ]] || {
            echo "${MSG:-"Expect var to be of int type: $*"}" >&2
            return 1
        }
        shift
    done
    return 0
}

: <<DOCTEST
> a=3; b=(1 2 3); c=8; d=(3 8)
> assert.var.is_array a b c 2>/dev/null && echo yes
> assert.var.is_array b d && echo yes
yes
DOCTEST
assert.var.is_array(){
    while [ $# -gt 0 ]; do
        if ! declare -p "${1:?Please provide variable name}" 2> /dev/null | grep -q '^declare \-a'; then
            echo "${MSG:-"Expect var to be of array type: $*"}" >&2
            return 1
        fi
        shift
    done
    return 0
}

testFun(){
    # Do it in usual way
    local TMP_1 TMP_2
    TMP_1=$(file.tmp)
    TMP_2=$(file.tmp)
    
    docker run -it ubuntu bash > "$TMP_1"
    MSG="testFun failed" \
        assert.grep "work" -- "work" <"$TMP_1"
    assert.grep "$(line "$TMP_1" 2)" "$TMP_2"
    MSG="testFun failed for reason like" \
        assert.grep "$(line "$TMP_1" 3)" "$TMP_2"

    # assert.grep "work" -- "testFun failed" <$TMP_1
    # assert.grep $(line $TMP_1 2) $TMP_2
    # assert.grep "$(line $TMP_1 3)" $TMP_2 -- "testFun failed for reason like" 

    # assert.eq 2 $(line $TMP_1 3)
    # assert.eq 2 $(file.line $TMP_1 3)
    # assert.eq 2 $(sed -n 3p $TMP_1)
}

# Example:
# TIMEOUT=3 MSGURE="Fail if wrong" @ts "work1" testFun1
# TIMEOUT=3 MSGURE="Fail if wrong" @testsuite "work1" testFun1
# TIMEOUT=5 @ts "work2" testFun2


: <<DOCTEST
> a=3; b=(1 2 3); c=
> assert.var.not_empty a b c && echo yes
> assert.var.not_empty a b && echo yes
yes
DOCTEST
assert.var.not_empty(){
    for i in "$@"; do
        [ -n "${!i}" ] || return 1
    done
}

# assert.strlen(){
#     local varname=${1:?Please provide variable name}
#     local val=${!$varname}
#     local len=${#val}
#     local expected_len=${2:?Expected length}
#     if [ "$len" -eq "$expected_len" ]; then
#         return 0
#     else
#         return 1
#     fi
# }

# The following code is ridiculously wrong ...
# assert.str_eq(){
#     local val=${!1:?Please provide variable name}
#     shift
#     for i in "$@"; do
#         if [ "$val" = "$i" ]; then
#             return 0
#         else
#             return 1
#         fi
#     done
# }

# assert.str_match_regex(){
#     local val=${!1:?Please provide variable name}
#     shift
#     for i in "$@"; do
#         if [[ "$val" =~ ^$i$ ]]; then
#             return 0
#         else
#             return 1
#         fi
#     done
# }
