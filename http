# shellcheck shell=bash

# Using object to make it right

# Using curl
# Using Object
# Provide Github Object, to help automate the github

@src std/dict
# @src std/oo # std/dict -> std/list -> std/oo

. dict
. oo

http.new(){
    oo.create_new_function http "$@"
}

http.make(){
    dict.make "${1:?Provide name}"

    local O="$1"

    dict.put "url" "${2:?Provide url}"
    # O="$1" dict.put "header" "${3:?Provide default header}"
    # eval "export ${1:?Provide name}_header=()"

    # dict.make "$(http._name.qs)"
    # dict.make "$(http._name.body)"
    # dict.make "$(http._name.header)"
}

# http._name.qs(){
#     echo "${O:?Provide name}_x-bash_http_qs"
# }

# http._name.body(){
#     echo "${O:?Provide name}_x-bash_http_body"
# }

# http._name.header(){
#     echo "${O:?Provide name}_x-bash_http_header"
# }

http.header.add(){ dict.put "header.${1:?header key}" "${2:?value}"; }
http.header.add_by_name(){ for i in "$@"; do http.header.add "$i" "${!i}"; done; }
http.header.remove(){ dict.remove "header.${1:?header key}"; }
http.header.dump(){
    [ -z "$O" ] && return 1
    # DICT_PRINT_SEP=': ' dict.print 
    DICT_PRINT_SEP=': ' dict.print | while read -d $'\n' -r l; do
        [[ "$l" =~ ^header\.* ]] && echo "${l:7}"
    done
}

http.header.dump.curl(){
    local IFS=$'\n'
    local A=()
    for i in $(http.header.dump); do
        A+=("-H \"$i\"")
    done
    IFS=$' '
    echo "${A[*]}"
}

http.header(){
    echo "$(http.header.dump)
$HEADER
"
}

http.header.content-type.eq(){
    http.header.add "Content-Type" "${1:?Content-Type candidates like application/json}"
}

http.header.content-type.eq.json+utf8(){ http.header.content-type.eq "application/json;charset=utf-8"; }
http.header.content-type.eq.json(){ http.header.content-type.eq "application/json"; }
http.header.content-type.eq.yml(){  http.header.content-type.eq "application/yml"; }
http.header.content-type.eq.text(){ http.header.content-type.eq "application/text"; }

http.header.referer.eq(){
    http.header.add "Referer" "${1:?Referer}"
}

http.header.agent.eq(){
    http.header.add "User-Agent" "${1:?User agent}"
}

http.dict.getput(){
    local O="${O:?Provide Object name}"
    case $# in
        1) http.dict.get "$1";;
        2) http.dict.put "$1" "$2";;
        *) echo "More than 2 variable provided" >&1; return 2;
    esac
}

http.dict.get(){
    local O="${O:?Provide Object name}"
    dict.get "${1:?Provide key}"
}

http.dict.put(){
    local O="${O:?Provide Object name}"
    dict.put "${1:?Provide key}" "${2:?Provide value}" 
}

http.cd(){
    [ -z "$O" ] && return 1
    local URL=${URL:-$(http.dict.get "url")}
    dict.put "url" "$URL/${1:?Provide url}"
}

# TODO: how to cd back

http.path(){
    local url
    url="$(http.dict.get "url")"
    if [ -z "$url" ]; then
        echo "$1"
    else
        # TODO: it is ugly... Isn't it?
        echo "$url$1"
    fi
}

http.qs.add(){ dict.put "qs.${1:?header key}" "${2:?value}"; }
http.qs.add_by_name(){ for i in "$@"; do http.qs.add "$i" "${!i}"; done; }
http.qs.remove(){ dict.remove "qs.${1:?header key}"; }
http.qs.dump(){
    [ -z "$O" ] && return 1
    DICT_PRINT_SEP='=' dict.print | while read -r l; do
        [[ "$l" =~ ^qs\.* ]] && echo "${l:3}"
    done
}

http.qs.dump.curl(){
    [ -z "$O" ] && return 1
    local A=()

    while read -rd $'\n' l; do
        [[ "$l" =~ ^qs\.* ]] && A+=("--data-urlencode \"${l:3}\"")
    done <<<"$( DICT_PRINT_SEP='=' dict.print )"

    local IFS=$' '
    echo "-G ${A[*]}"
}

http.eq_str_by_name(){
    for i in "$@"; do
        echo "$i=${!i}"
    done
}

http.body.add(){ dict.put "body.${1:?header key}" "${2:?value}"; }
http.body.add_by_name(){ for i in "$@"; do http.body.add "$i" "${!i}"; done; }
http.body.remove(){ dict.remove "body.${1:?header key}"; }
http.body.dump.json(){
    [ -z "$O" ] && return 1
    # DICT_PRINT_SEP=': ' dict.print | while read -r l; do
    #     [[ "$l" =~ ^body\.* ]] && echo "${l:5}"
    #     echo "1: $l"
    # done | dict.__toJSON

    local l1 l2
    DICT_PRINT_SEP=$'\n' dict.print "body.*" | while :; do
        read -rd $'\n' l1 || break
        read -rd $'\n' l2 || break
        echo "${l1:5}"
        echo "$l2"
    done | dict.__toJSON "$@"
}

http.resp.header(){
    local filter=${1:?provide filter} A
    A="$(grep "$filter:" "${TMPDIR}x-cmd-x-bash-std-http-${O:?Please provide O}")"
    A="${A##$filter: }"
    echo -n "${A%"${A##*[![:space:]]}"}"
}

http.request(){
    local O="${O:?Please provide O}"

    local X=${X:-get)} data=${2:-"$D"} path
    path="$(http.path "$1")"

    if [ -z "$data" ]; then
        data="$(http.body.dump.json "")"
    fi

    local tmp
    tmp=$(mktemp)
    echo "$data" > "$tmp"

    local code
    if [ "$X" = GET ] || [ "$X" = DELETE ] || [ "$X" = HEAD ]; then
        # echo curl --fail -D "${TMPDIR}x-cmd-x-bash-std-http-$O" -X "$X" "$(http.qs.dump.curl)" "$(http.header.dump.curl)" "$path"  
        eval curl --fail -D "${TMPDIR}x-cmd-x-bash-std-http-$O" -X "$X" "$(http.qs.dump.curl)" "$(http.header.dump.curl)" "$path" 2>/dev/null
        code=$?
    else
        eval curl --fail -D "${TMPDIR}x-cmd-x-bash-std-http-$O" -X "$X" "$(http.header.dump.curl)" -d "@$tmp" "$path" 2>/dev/null
        code=$?
    fi
    rm "$tmp"
    return $code
}

http.request.json_body(){
    local url=$1
    shift
    (
        for i in "$@"; do
            if [[ "$i" = *=* ]]; then
                http.body.add "${i%=*}" "${i##*=}"
            else
                http.body.add "$i" "${!i}"
            fi
        done
        
        http.request "$url" "$(http.body.dump.json "")"
    )
}

# crud
http.post(){ X=POST http.request "$@"; }
http.post.json(){ X=POST http.request.json_body "$@"; }
# TODO
http.post.form(){ X=POST http.request.json_body "$@"; }
http.post.text(){ X=POST http.request.json_body "$@"; }
http.post.bin(){ X=POST http.request.json_body "$@"; }

http.get(){
    local url=$1
    shift
    (
        for i in "$@"; do
            if [[ "$i" = *=* ]]; then
                http.qs.add "${i%=*}" "${i##*=}"
            else
                http.qs.add "$i" "${!i}"
            fi
        done
        
        X=GET http.request "$url"
    )
}

http.put(){ X=PUT http.request "$@"; }
http.put.json(){ X=PUT http.request.json_body "$@"; }
# TODO
http.put.form(){ X=PUT http.request.json_body "$@"; }
http.put.text(){ X=PUT http.request.json_body "$@"; }
http.put.bin(){ X=PUT http.request.json_body "$@"; }

http.delete(){ X=DELETE http.request "$@"; }

http.head(){ X=HEAD http.request "$@"; }
