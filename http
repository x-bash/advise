# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao

@src std/dict  # @src std/oo # std/dict -> std/list -> std/oo

############################
# Section 1: Instantiation & Utilities
# Section 2: Dict & Path
# Section 3: Header
# Section 4: QueryString & Body
# Section 5: Request & Response
# Section 6: CRUD -- post get put delete
############################

############################
# Section 1: Instantiation & Utilities
############################
http.new(){  oo.create_new_function http "$@";  }

http.make(){
    dict.make "${1:?Provide name}"
    local O="$1"
    dict.put "url" "${2:?Provide url}"
}

http.browse(){
    local BROWSER=${BROWSER:-$BROWSER}
    local website=${1:?Provide websites}
    if [ -n "$BROWSER" ]; then
        $BROWSER "$website"
    elif uname -a | grep -q Darwin; then
        open -a "/Applications/Safari.app" "$website"
    elif command -v xdg-open > /dev/null; then
        xdg-open "$website"
    elif command -v gnome-open > /dev/null; then
        gnome-open "$website"
    else
        echo "Could not detect the web browser to use."
        return 1
    fi
}

http.debug(){
    local IFS=
    [[ "$X_BASH_DEBUG" =~ (^|,)(std/)*http($|,) ]] && printf "DBG: %s\n" "$@" >&2
}

############################
# Section 2: Dict & Path
############################
http.dict.getput(){
    local O="${O:?Provide Object name}"
    case $# in
        1) http.dict.get "$1";;
        2) http.dict.put "$1" "$2";;
        *) echo "More than 2 variable provided" >&1; return 2;
    esac
}

http.dict.get(){
    local O="${O:?Provide Object name}"
    dict.get "${1:?Provide dict key}"
}

http.dict.put(){
    local O="${O:?Provide Object name}"
    dict.put "${1:?Provide dict key}" "${2:?Provide dict value}" 
}

http.cd(){
    [ -z "$O" ] && return 1
    local URL=${URL:-$(http.dict.get "url")}
    dict.put "url" "$URL/${1:?Provide url}"
}

http.path(){   # TODO: how to cd back
    local url
    url="$(http.dict.get "url")"
    if [ -z "$url" ]; then
        echo "$1"
    else
        echo "$url$1" # TODO: it is ugly... Isn't it?
    fi
}

############################
# Section 3: Header
############################
http.header.put(){ 
    dict.put "header.${1:?header key}" "${2:?value}"; 
}

http.header.mput(){
    for i in "$@"; do
        if [[ "$i" = *=* ]]; then
            http.header.put "${i%=*}" "${i##*=}"
        else
            http.header.put "$i"
        fi
    done
}

http.header.remove(){ dict.remove "header.${1:?header key}"; }
http.header.dump(){
    [ -z "$O" ] && return 1
    # DICT_PRINT_SEP=': ' dict.print 
    DICT_PRINT_SEP=': ' dict.print | while read -d $'\n' -r l; do
        [[ "$l" =~ ^header\.* ]] && echo "${l:7}"
    done
}

http_.header.dump.curl_args(){
    local IFS=$'\n'
    local A=()
    for i in $(http.header.dump); do
        A+=("-H \"$i\"")
    done
    IFS=$' '
    echo "${A[*]}"
}

http.header(){
    echo "$(http.header.dump)
$HEADER
"
}

http.header.content-type.eq(){
    http.header.put "Content-Type" "${1:?Content-Type candidates like application/json}"
}

http.header.content-type.eq.json+utf8(){ http.header.content-type.eq "application/json;charset=utf-8"; }
http.header.content-type.eq.json(){ http.header.content-type.eq "application/json"; }
http.header.content-type.eq.yml(){  http.header.content-type.eq "application/yml"; }
http.header.content-type.eq.text(){ http.header.content-type.eq "application/text"; }

http.header.referer.eq(){
    http.header.put "Referer" "${1:?Referer}"
}

http.header.agent.eq(){
    http.header.put "User-Agent" "${1:?User agent}"
}


############################
# Section 4: QueryString & Body
############################
# Notice: http.qs.put will put the empty value
http.qs.put(){
    dict.put "qs.${1:?header key}" "${2:-${!1}}"
}

# Notice 1: `http.qs.put abc=``  will put the entry { abc: "" }
# Notice 2: `abc=; http.qs.put abc` will NOT put any entry
http.qs.mput(){
    local value
    for i in "$@"; do
        if [[ "$i" = *=* ]]; then
            http.qs.put "${i%=*}" "${i##*=}"
        else
            value=${!i}
            [ -n "$value" ] && http.qs.put "$i" "$value"
        fi
    done;
}

http.qs.remove(){ dict.remove "qs.${1:?header key}"; }
http.qs.dump(){
    [ -z "$O" ] && return 1
    DICT_PRINT_SEP='=' dict.print | while read -r l; do
        [[ "$l" =~ ^qs\.* ]] && echo "${l:3}"
    done
}

http.qs.dump.curl(){
    [ -z "$O" ] && return 1
    local A=()

    while read -rd $'\n' l; do
        [[ "$l" =~ ^qs\.* ]] && A+=("--data-urlencode \"${l:3}\"")
    done <<<"$( DICT_PRINT_SEP='=' dict.print )"

    local IFS=$' '
    echo "-G ${A[*]}"
}

# Just in case.
http.body.put(){
    local value="${2:-${!1}}"
    dict.put "body.${1:?header key}" "$value"
    # [ -n "$value" ] && dict.put "body.${1:?header key}" "$value"
}

# Redis like naming
http.body.mput(){
    local value
    for i in "$@"; do
        if [[ "$i" = *=* ]]; then
            http.body.put "${i%=*}" "${i##*=}"
        else
            value="${!i}"
            [ -n "$value" ] && http.body.put "$i" "$value"
        fi
    done;
}

http.body.remove(){ dict.remove "body.${1:?header key}"; }
http.body.dump.json(){
    [ -z "$O" ] && return 1
    # DICT_PRINT_SEP=': ' dict.print | while read -r l; do
    #     [[ "$l" =~ ^body\.* ]] && echo "${l:5}"
    #     echo "1: $l"
    # done | dict.__toJSON

    local l1 l2
    DICT_PRINT_SEP=$'\n' dict.print "body.*" | while :; do
        read -rd $'\n' l1 || break
        read -rd $'\n' l2 || break
        echo "${l1:5}"
        echo "$l2"
    done | dict.__toJSON "$@"
}

############################
# Section 5: Request & Response
############################
http.resp.header.all(){
    cat "$(http_.resp.latest.header.filepath)"
}

http.resp.header(){
    local filepath
    filepath="$(http_.resp.latest.header.filepath)"
    local filter=${1:?provide filter} A
    A="$(grep "$filter:" "$filepath")"
    A="${A##$filter: }"
    echo -n "${A%"${A##*[![:space:]]}"}"
}

http.resp.body(){
    cat "$(http_.resp.latest.body.filepath)"
}

http_.resp.latest.header.filepath(){
    echo "${TMPDIR}x-cmd-x-bash-std-http-header.${O:?Please provide O}"
}

http_.resp.latest.body.filepath(){
    echo "${TMPDIR}x-cmd-x-bash-std-http-body.${O:?Please provide O}"
}

http_.request(){
    local IFS=$' '
    local O="${O:?Please provide O}"

    local X=${X:-get)} data=${2:-"$D"} path
    path="$(http.path "$1")"

    if [ -z "$data" ]; then
        data="$(http.body.dump.json "")"
    fi

    local tmp
    tmp=$(mktemp)
    echo "$data" > "$tmp"
    [ -n "$DEBUG" ] && echo "body is: $data" >&2

    local REDIRECT=/dev/null
    [ -n "$DEBUG" ] && REDIRECT=/dev/stderr

    local header_filepath data_filepath
    header_filepath="$(http_.resp.latest.header.filepath)"
    data_filepath="$(http_.resp.latest.body.filepath)"

    if [ "$X" = GET ] || [ "$X" = DELETE ] || [ "$X" = HEAD ]; then
        echo curl -D "$header_filepath" -X "$X" "$(http.qs.dump.curl)" "$(http_.header.dump.curl_args)" "$path" 1>$REDIRECT
        eval curl -D "$header_filepath"  -X "$X" "$(http.qs.dump.curl)" "$(http_.header.dump.curl_args)" "$path" 2>$REDIRECT 1>"$data_filepath"
    else
        echo curl -D "$header_filepath" -X "$X" "$(http_.header.dump.curl_args)" -d "@$tmp" "$path" 1>$REDIRECT
        eval curl -D "$header_filepath" -X "$X" "$(http_.header.dump.curl_args)" -d "@$tmp" "$path" 2>$REDIRECT 1>"$data_filepath"
    fi
    rm "$tmp"

    [ -n "$DEBUG" ] && {
        echo -e "\n------------"
        echo "Response Header is:"
        cat "$header_filepath"
        echo -e "------------\n"
    } >&2

    local a b c
    read -r a b c <<<"$(cat "$header_filepath")"
    
    if [ -n "$b" ] && [ "$b" -ge 200 ] && [ "$b" -le 299 ]; then
        cat "$data_filepath"
        # printf "HttpCode is %s, Code is 0\n" "$b" >&2
        return 0
    fi

    [ -n "$DEBUG" ] && echo "$data" >&2
    printf "HttpCode is %s, Code is 1\n" "$b" >&2
    return 1
}

http_.request.json_body() (  # Notice: Using subshell
    url=$1;  shift
    http.body.mput "$@"
    http_.request "$url" "$(http.body.dump.json "")"
)

############################
# Section 6: CRUD -- post get put delete
############################

# crud
http.post(){ X=POST http_.request "$@"; }
http.post.json(){ X=POST http_.request.json_body "$@"; }
# TODO
http.post.form(){ X=POST http_.request.json_body "$@"; }
http.post.text(){ X=POST http_.request.json_body "$@"; }
http.post.bin(){ X=POST http_.request.json_body "$@"; }

http.get() (    # Notice: Using subshell
        url=$1;  shift
        http.qs.mput "$@"
        X=GET http_.request "$url"
)

http.put(){ X=PUT http_.request "$@"; }
http.put.json(){ X=PUT http_.request.json_body "$@"; }
# TODO
http.put.form(){ X=PUT http_.request.json_body "$@"; }
http.put.text(){ X=PUT http_.request.json_body "$@"; }
http.put.bin(){ X=PUT http_.request.json_body "$@"; }

http.delete(){ X=DELETE http_.request "$@"; }

http.head(){ X=HEAD http_.request "$@"; }
